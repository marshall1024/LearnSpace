**1.1.数据库的4个基本概念**

​	Data: 数据，是数据库中存储的基本对象，是描述事物的符号记录。

​	Database: 数据库，是长期存储在计算机内、有组织的、可共享的大量数据的集合。

​	DBMS(DataBase Management System): 数据库管理系统，是位于用户与操作系统之间的一层数据管理软件，用于科学地组织、存储和管理数据、高效地获取和维护数据。

​		主要功能：数据定义功能；数据组织、存储和管理；数据操纵功能；数据库的事物管理和运行管理；数据库的建立和维护功能；其它功能

​	DBS(DataBase system): 数据库系统，指在计算机系统中引入数据库后的系统，一般由数据库、数据库管理系统、应用系统、数据库管理员(DBA)构成。 

**1.2.数据模型与数据建模**

​	数据模型(data model): 是用来抽象、表示和处理现实世界中的数据和信息的工具，是对现实世界的模型，是数据库系统的核心和基础。

​		三个要素：数据结构(对模型静态特性的描述)；数据操作(对模型动态特性的描述)；数据的完整性约束。

​		常用的数据模型: 层次模型；网状模型；关系模型；不断涌现的新型数据模型(键值对数据模型；文档数据模型)

​	数据建模(data modeling): 怎么建立数据模型，把现实世界中的具体事物抽象、组织为某一DBMS支持的数据模型。

​		概念模型: 也称信息模型，是按用户的观点来对数据和信息建模，主要用于数据库设计。

​			实体-联系方法(E-R方法，E-R图): 用于描述现实世界的事物及其相互关系，是数据库概念模型设计的主要工具。

​		逻辑模型: 是按计算机系统的观点对数据建模，用于DBMS实现。

​		物理模型: 是对数据最底层的抽象，描述数据在系统内部的表示方式和存储方法，在磁盘或磁带上的存储方式和存取方法，是面向计算机系统的。

​		数据建模过程：两步抽象

​			把现实世界中的客观对象抽象为概念模型，将<u>现实世界抽象为信息世界</u>

​			把概念模型转换为某一DBMS支持的数据模型(逻辑模型)，将<u>信息世界转换为机器世界</u>(物理模型)

**1.3.数据库系统的三级模式结构**

​	型/值：型是对某一类数据的结构和属性的说明；值是型的一个具体赋值和型的实例。

​	模式(schema): 也称逻辑模式，是对数据库中全体数据的逻辑结构(数据项的名字、类型、取值范围灯)和特征(数据之间的联系以及数据有关的安全性、完整性要求)的描述。

​		实例(instance): 模式的一个具体值。

​	外模式(external schema): 也称子模式或用户模式，它是数据库用户能够看见和使用的局部数据的逻辑结构和特征的描述，是数据库用户的数据试图。通常是模式的子集。一个数据库可有多个外模式。例如，关系数据库中的视图

​	内模式(internal schema):  又称为存储模式，是对数据库物理结构和存储方式的描述，是数据在数据库内部的表示方式。一个数据库只有一个内模式。

<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库.assets\image-20250412094540621.png" alt="image-20250412094540621" style="zoom:50%;" />

​	数据库的二级映像: 

​		外模式/模式映像: 映像定义通常包含在各自外模式的描述中，提高数据的逻辑独立性。

​		模式/内模式映像: 定义了数据全局逻辑结构与存储结构之间的对应关系，映像定义通常包含在模式描述中，保证数据的物理独立性。

**2.1关系模型**

​	要素一：数据结构

​		关系(Relation): 一个关系对应通常说的一张表

​		元组(Tuple)：表中的一行即一个元组。

​		属性(Attribute)：表中的一列即为一个属性，给每一个属性起一个名称即属性名。

​		主码(Key)：也称码键，表中单得某个属性组，它可以唯一确定一个元组。

​		域(Domain)：是一组具有相同数据类型的值的集合。属性的取值范围来自某个域。

​		分量：元组中的一个属性值。

​		关系模式：对关系的描述，简单地说，关系模式就是对关系的型的定义，包括关系的属性构成、各属性单得数据类型、属性间的依赖、元组语义及完整性约束灯。关系是关系模式在某一时刻的状态或内容，关系模型是型，关系是值，关系模型是静态的、稳定的，而关系是动态的、随时间不断变化的，因为关系操作在不断地更新着数据库中的数据。

​			五元组形式化表示为：R(U, D, DOM, F)

​			R——关系名

​			U——组成该关系的属性名集合

​			D——属性组U中属性所来自的域

​			DOM——属性向域的映射集合

​			F——属性间的数据依赖关系集合

​	要素二：数据操作

​		数据操作是集合操作，操作对象和操作结果都是关系。

​		查询、插入、删除、更新

​	要素三：数据的完整性约束

​		实体完整性：用于标识实体的唯一性。它要求基本关系必须要有一个能够标识元组唯一性的主键，主键不能为空，也不可取重复值。

​		参照完整性:用于维护实体之间的引用关系。它要求一个关系的外键要么为空，要么取与被参照关系对应的主键值，即外键值必须是主键中已存在的值。

​		用户定义的完整性：就是针对某一具体应用的数据必须满足的语义约束。包括非空、唯一和布尔条件约束三种情况。

​	优点：建立在严格的数学概念的基础上；概念单一；关系模型的存取路径对用户透明；

​	缺点：存取路径对用户透明，查询效率往往不如格式化数据模型；为提高性能，必须对用户的查询请求进行优化，增加了开发数据管理系统的难度。

​	关系数据库语言：关系代数、关系演算、结构化查询

**2.2关系代数**

​	定义：用对关系的运算来表达查询的语言

​	关系代数运算：

​		运算的三大要素：运算对象、运算符、运算结果

​			1.关系代数的运算对象是关系，运算结果亦为关系

​			2.运算符：集合运算符(U:并，-:差，∩:交，×:笛卡尔积) 专门关系运算符(σ:选择，Π:投影，⨝:连接，÷:除法)

​		传统的集合运算——从关系的”水平“方向，即行的角度进行运算

​			并运算：设关系R和S具有相同的目n(即两个关系都有n个属性列)，且相应的属性取自同一个域，则关系R和S的并由属性R或属于S的元组组成。记作：RUS={t|t∈R∨t∈S}

​			交运算：设关系R和S具有相同的目n，且对应的属性取自同一个域，则关系R和S的交由既属于R又属于S的元组组成。记作：R∩S={t|t∈R^t∈S}

​			差运算：设关系R和S具有相同的目n，且对应的属性取自同一个域，则关系R和S的差由属于R而不属于S的所有元组组成。记作：R-S={t|t∈R^t∉S}

​			广义笛卡尔积：两个分别为n目和m目的关系R和关系S的广义笛卡尔积是一个(n+m)列的元组集合，若R有k1个元组，S有k2个元组，则关系R和关系S的广义笛卡尔积有k1×k2个元组。记作：R×S={t|t=<tn,tm>^tn∈R^tm∈S}

​		专门的关系运算——不仅涉及行而且涉及列

​			选择运算：选择又称限制，在关系R中选择满足给定条件的元组。记作：<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库.assets\image-20250410215422675.png" alt="image-20250410215422675" style="zoom:50%;" />

​			投影运算：关系R上的投影是从R中选择出若干属性列组成新的关系。记作：<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库.assets\image-20250410215339957.png" alt="image-20250410215339957" style="zoom:50%;" />

​			连接运算：连接也称θ连接，从两个关系的笛卡尔积中选取属性间满足一定条件的元组。记作：<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库.assets\image-20250410215757709.png" alt="image-20250410215757709" style="zoom:50%;" />

​				等值连接：从关系R和关系S的笛卡尔积中选取A、B属性值相等的那些元组。记作：<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库.assets\image-20250410220010775.png" alt="image-20250410220010775" style="zoom:50%;" />

​				自然连接：自然连接是一种特殊的等值连接，它要求两个关系中进行比较的分量必须是相同的属性组，并且要在结果中把重复的属性去掉。若R和S具有相同的属性列B，U为R和S全体属性集合，则自然连接可记作：<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库.assets\image-20250410220339092.png" alt="image-20250410220339092" style="zoom:50%;" />

​				外连接：如果把悬浮元组(把两个关系在做自然连接时舍弃的元组)也保存在R和S自然连接(R∞S)的结果关系中，而在其他属性上填空值，则这种连接就叫做外连接。若只保留左边关系R中的悬浮元组称为左外连接，若只保留右边关系R中的悬浮元组称为右外连接。

​				除运算：给定关系R(X, Y)和S(Y, Z)，其中X,Y,Z为属性组，R中的Y与S中的Y可以有不同的属性名，但必须出自相同的域集。R和S的除运算得到一个新的关系P(x)，P是R中满足下列条件的元组在X属性列上的投影：元组在X上分量值X的象集Yx包含S在Y上投影的集合。记作：<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库.assets\image-20250410221357655.png" alt="image-20250410221357655" style="zoom:50%;" />

**2.3关系演算**

定义：以数理逻辑中的谓词演算为基础的数据库语言。

按谓词变元不同划分：

​	1.元组关系演算：以元组变量作为谓词变元的基本对象，演算语言ALPHA。

​			6个语句：GET，PUT，HOLD，UPDATE，DELETE，DROP

​			基本格式：操作语句 工作空间名（表达式）：操作条件

​	2.域关系演算：以元组变量的分量(域变量)作为谓词变元的基本对象，演算语言QBE。

​			元组变量：变化范围是在某一关系内。使用量词时必须用元组变量。

**3.1结构化查询语言-SQL数据定义**

​	定义：结构化查询语言的简称，是关系数据库的标准语言。SQL是一种通用的、功能极强的关系数据库语言，是对关系数据存取的标准接口，也是不同数据库系统之间互操作的基础。集数据查询、数据操作、数据定义、和数据控制功能于一体。

​	1.数据库创建

​		【例】为用户Zhang在Eduspace表空间创建Education数据库

​		CREATE DATABASE Education OWNER = Zhang TABLESPACE Eduspace;

​		表空间TABLESPACE是分配给数据库的一组物理文件的逻辑名称，是存储数据库对象的空间。

​		一个数据库可以被多个用户访问。数据库和用户之间是独立的。用户可以访问数据库种不同模式下的所有对象，只要该用户有合法权限。

​	2.模式的定义

​		【例】为用户WANG定义一个学生选课模式S-C-SC

​		CREATE SCHEMA ”S-C-SC“ AUTHORIZATION WANG;

​		1.一个数据库中可以建立多个模式

​		2.创建数据库时，RDBMS通常会自动创建3个模式：public、sys和sysaudit。

​		public模式为公共模式，如果创建表等数据库对象时不指定模式名，通常默认在Public模式中创建；

​		sys模式存储该数据库的系统表和系统视图等系统数据库对象；

​		sysaudit模式存储审计相关的数据库对象。

​	3.模式与表的关系

​		1.一个模式可以包含多个基本表，每个基本表属于某一个模式

​		2.定义基本表所属模式

​			方法一：在表名中明显地给出模式名; create table "schemaName".tableName(...)

​			方法二：在创建模式语句中同时创建表;create schema "schemaName" authorization wang create table tableName(...)

​			方法三：设置所属的模式;set search_path to "schamaName", PUBLIC

​	4.数据定义

​		1.定义基本表: create table <表名> (<列名> <数据类型> [<列级完整性约束条件] [<,表级完整性约束>])

​			<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250412161517591.png" alt="image-20250412161517591" style="zoom:50%;" />

​		2.删除基本表：drop table <表名> [restrict|cascade]

​			restrict——该表删除时有限制的，待删除的表不能被其他表的约束所引用，否则不能删除；

​			cascade——删除表的同时删除其他约束对象。一般默认是restrict;

​		3.修改基本表：alter table <表名> [add <新列名> <数据类型> [完整性约束] ] [drop <原列名>|<完整性约束名>] [alter column <原列名> <数据类型>]

​		4.索引的建立与删除

​			建立索引——建立索引是加快查询速度的有效手段：create index <索引名> on <表名>(<列名 [,<列名>]>)；

​			删除索引: drop index <索引名>;

​	5.数据字典

​		定义：数据字典是关系数据库管理系统内部的一组系统表，它记录了 关系模式定义；视图定义；索引定义；完整性约束定义；各类用户对数据库的操作权限；统计信息等

**3.2SQL查询**

​	1.基本查询：select [all|distinct]<目标列表达式>[, <目标列表达式>]... from <表或视图名>[,<表或视图名>]...[where <条件表达式>] [group by <列名> [having <条件表达式>]] [order by <列名>[asc|desc]] [limit <行数> [offset <行数>]]

​		查询条件：

<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250412163828966.png" alt="image-20250412163828966" style="zoom:50%;" />

​		集合函数：

​			1.行计数——count([distinct|all]*)对每行计数；distinct短语表示在计算时要取消指定列中的重复值；all短语表示不取消重复值，all为缺省值。

​			2.行计数——count([distinct|all]<列名>)对<列名>非空的行计数

​			3.计算总和(对非空列)——sum([distinct|all]<列名>)

​			4.计算平均值(对非空列)——avg([distinct|all]<列名>)

​			5.求最大值(对非空列)——max([distinct|all]<列名>)

​			6.求最小值(对非空列)——min([distinct|all]<列名>)

​	2.复杂SQL查询

​		连接查询：查询同时涉及两个以上的表，则称之为连接查询。连接查询的where子句中用来连接两个表的条件称为连接条件或连接谓词，其一般格式为：[<表名1>.]<列名1> <比较运算符> [<表名2>.]<列名2>  此外连接谓词还可以为：[<表名1>.]<列名1> between [<表名2>.]<列名2> and [<表名2>.]<列名3>

​			等值连接查询：等值连接的运算符是=

​			非等值连接查询：不是=的连接操作就是非等值连接

​			自然连接查询：若在等值连接中把目标列中重复的属性列去掉则为自然连接。

​			自身连接查询：一个表与其自己进行连接，称为表的自身连接。

​			外连接查询(Outer Join)：普通连接操作只输出满足连接条件的元组，外连接可以保留不满足条件的元组。

​				左外连接——将左边关系的不满足连接条件的行输出。

​				右外连接——将右边关系的不满足连接条件的行输出。

​				全外连接——将两边关系的不满足连接条件的行输出。

​			复合条件连接查询：where子句中有个多个连接条件，称为复合条件连接

​		嵌套sql查询：

​			定义：一个select-from-where语句称为一个查询块。将一个查询块嵌套在另一个查询块的where子句或having短语的条件中的查询称为嵌套查询。

​			不相关子查询：子查询的查询条件不依赖于父查询

​			相关子查询：子查询的查询条件依赖于父查询

​			引出子查询的谓词：

​				带有IN谓词的子查询

​				带有比较运算符的子查询(=, >, <, >=, <=, != 或 <>)

​				带有exists谓词的子查询

​		基于派生表的查询:

​			定义：子查询出现在from子句中，子查询生成的临时派生表(derived table)，成为主查询的查询对象。

​	3.空值

​		定义：空值就是”不知道“、”不存在“或“无意义”的值，空值是一个很特殊的值，含有不确定性。

​		空值的产生：

​			插入数据会产生空值；

​			修改数据会产生空值；

​			外连接会产生空值。

​		空值的运算：

​			判断属性值是否为空值，用is null或is not null来表示；

​			排序遇到空值时，排序现实的次序由具体系统实现来决定；

​			当聚集函数遇到空值时，除count(*)外，都跳过空值而只处理非空值；

​			空值的算术运算、比较运算和逻辑运算：T表示true，F表示FAlSE，U表示UNKNOWN

​			<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250412174542514.png" alt="image-20250412174542514" style="zoom:50%;" />

​				空值与另一个值(包括另一个空值)的算术运算的结果为空值.

​				空值与另一个值(包括另一个空值)的比较运算的结果为UNKNOWN.

​				有UNKOWN后，传统的逻辑运算中二值逻辑就扩展成了三值逻辑.

​		空值约束：

​			主码的属性不能取空值

​			在创建基本表时，如果属性定义(或着阈定义)为NOT NULL 约束，则该属性不能取空值

​		空值约束与唯一值约束的关系：

​			如果属性定义(或着域定义)为UNIQUE约束，那么该属性能不能取空值，SQL标准中对此没有明确规定

**3.3数据更新**

​	插入数据：

​		插入单个元组：insert into <表名> [(<属性列1>[, <属性列2>]] values (<常量1> [, <常量2>]...)

​		插入子查询结果：insert into <表名> [(<属性列1>[, <属性列2>]]  子查询；

​	修改数据：

​		修改元组值：update <表名> set <列名>=<表达式>[, <列名>=<表达式>]... [where <条件>]；

​		带子查询的修改语句：update set <列名>=<表达式>[, <列名>=<表达式>]... [where <条件>子查询语句]

​	删除数据：delete from <表名> [where <条件>];

**4.1用户身份鉴别**

**4.2权限的表达与检查**

​	存储控制机制：通过用户和数据之间的”权限“匹配实现对用户访问数据的安全控制。

​	两类机制：自主存取控制；强制存取控制；

​	1.自主存取控制(DAC):

​	权限授予：grant <权限>[,<权限>]... on <对象类型><对象名>[,<对象类型> <对象名>]... to <用户>[,<用户>]... [with grant option]; 

​		with grant option表示"再授权"。循环授权式不允许的，授权时候需要检查；多方授权是允许的；

​	权限收回：revoke <>[,<>]... on <> <> [,<对象类型><对象名>]... from <用户>[,<用户>]...[cascade|restrict];

​		cascade——级联收回授予的权限

​		restrict(默认)——如果转授了权限，则不能收回

​	数据库角色：ROLE就是一组授权

​		创建角色：create role <角色名>；

​		角色授权：grant <权限>[,<权限>]... on <对象类型>对象名[,...] to <角色名>；

​		角色授权角色或用户：grant R1 to U2|R2

​		角色转授：with admin option

​	2.强制存取控制(MAC)：

​		通过给用户（主体）和数据（客体）赋予不同的安全级别，控制数据访问。

​		比DAC具有更高程度的安全性。因为，即使拥有对表的访问权限，但是如果密级不匹配，也无法访问数据。

​		适用于对数据有严格而固定密级分类的部门：军事部门；政府部门。

​		敏感标记(Label)：

​			对于主体和客体，DBMS为它们每个实例指派一个敏感度标记

​			敏感度标记分为若干级别：TS>=S>=C>=P

​				绝密（Top Secret, TS）

​				机密（Secret, S）

​				可信（Confidential, C）

​				公开（Public, P）

​		主体的敏感度标记称为许可证级别（Clearance Level）

​		客体的敏感度标记称为密级（Classification Level）

​		强制存储控制规则：

​			1.仅当主体的许可证级别大于或等于客体的密级时，该主体才能读取相应的客体。

​			2.仅当主体的许可证级别小于或等于客体的密级时，该主体才能写相应的客体。

**5.1数据库完整性**

​	数据库完整性约束的分类与表达

​		模型固有的约束：

​			实体完整性，例如：学生的学号必须唯一

​			参照完整性，例如：学生所选的课程必须是学校开设的课程

​		用户定义的约束：

​			属性类型，例如：百分制的课程成绩取整数（成绩不带小数点）

​			复杂条件，例如：同一个教学班的学生成绩优秀率不得高于30%

​	数据库完整性机制

​		1.完整性约束条件的表达和定义机制

​		2.提供检查完整性约束的方法

​		3.提供完整性违约处理的方法

​	通用工具——触发器

​		定义：触发器是用户定义在关系表上的一类由事件驱动的特殊过程

​		触发器可以实施更为复杂的检查和操作，具有更精和更强大的数据控制能力。

​		触发器保存在数据库服务器中。

​		任何用户对表的增、删、改操作均有服务器自动激活相应的触发器，在RDBMS核心层进行集中的完整性控制。

​		触发器：事件-条件-动作(Event-Condition-Action, ECA)规则。

​		CREATE TRIGGER语法格式：

​			create trigger <触发器名> 

​			{before|after} <触发器事件> on <表名>

​			referencing new|old row as <变量>

​			for each {row|statement} [when <触发条件>]<触发动作体>

​		删除触发器语法：drop trigger <触发器名> on <表名>

**6.1函数依赖**

​	数学函数关系：y=f(x)，自变量确定后，y也唯一地确定了。如果关系R的两个属性X和Y之间存在类似函数的关系，则称X和Y之间存在函数依赖。表示为X—>Y，X函数决定Y，或者，Y函数依赖X.

​	定义1：设R(U)是一个属性集U上的关系模式，X和Y是U的子集。若对于R(U)的任意一个可能的关系r，r中不可能存在两个元组在X上的属性值相等，而在Y上的属性值不等，则称“X函数确定Y”或“Y函数依赖于X”，记作X->Y.X称为这个函数依赖的决定属性组，也称为决定因素（Determinat）.

​	函数依赖的图形表达：

​		关系STUDENT(Sno, Sdept, Mname, Cno, Grade)

​		函数依赖集合F: F = {Sno—>Sdept, Sdept—>Mname, (Sno, Cno)—>Grade}

<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250416220022283.png" alt="image-20250416220022283" style="zoom:50%;" />

​	如何确定函数依赖：

​		函数依赖是语义范畴的概念。只能根据数据的语义来确定函数依赖。

​		数据库设计者可以对现实世界作强制的规定。

​		函数依赖是指关系模式R在任何时刻的关系实例均要满足的约束条件。

​	函数依赖的作用：更重要的作用在于指导数据库

​	部分函数依赖：

​		定义2：在关系模式R(U)中，如果X—>Y，并且存在X的一个真子集X', 且X' —>Y, 则称Y部分函数依赖于X，记作X—P—>Y。否则成为完全函数依赖，记作X—F—>Y。

​	传递函数依赖：

​		定义3：在R(U)中，如果X—>Y，(Y∉X)，Y不决定X，Y—>Z，则称Z对X传递函数依赖。记为<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250418204148828.png" alt="image-20250418204148828" style="zoom:50%;" />

​		注意：如果Y—>X，即X—>Y，X<——>Y， 则Z直接依赖于X。

​	主码：

​		定义4：设K为关系模式R(U，F)中的属性或属性组合。若K—F—>U(K完全依赖U)，则K称为R的一个候选码（Candidate Key）.

​		超码：如果U部分函数依赖K，即K—p—U,则K称为超码（Surpkey）

​		超键：同超码，在关系中能唯一标识元组的属性或属性集

​		候选码是最小的超码，即K的任意一个真子集都不是候选码。

​		候选键：不含多余属性的超键。

​		主码：若关系模式R有多个候选码，则选定其中的一个做为主码(Primary key).

​		主键：同主码，能够唯一地标识一个元组的属性或属性组称为关系的键或候选键。若一个关系有多个候选键则可选其一作为主键（Primary key）

​	主属性：

​		包含在任何一个候选码中的属性，称为主属性（Prime attribute）.

​		非主属性：不包含在任何码中的属性称为非主属性（Nonprime attribute）或非码属性（Non-Key attribute）

​		全码：整个属性组是码，称为全码（All-key）

​	外码：

​		定义5: 关系模式R（U，F）,U中属性或属性组X并非R的码，但X是另一个关系模式的码，则称X是R的外部码（Foreign key）也称外码。

​		外键：如果一个关系的一个或一组属性引用了另一个关系的主键，则称这个或这组属性为外码或外键

**6.2多值依赖**

​	定义：设R(U)是关系模式，X,Y,Z是U的子集，并且Z=U-X-Y(Z是X,Y的补集)，如果对R(U)的任意一个具体关系r给定一个指（X,Z），有一组Y值，只与X有关与Z无关，则称X和Y之间存在多值依赖，记为X—>—>Y

​	解释：X=x确定后，Y与Z之间不存在任何关系，也就是：Y(x) × Z(x) 是R(x)的子集。

​	多值依赖与函数依赖的关系：

​		函数依赖是多值依赖的特例：

​			单值是多值的特列。

​			相当于是一个单值集合，{单值}。

​		多值依赖不如函数依赖有很多好的性质：

​			若X—>Y，Z是Y的子集，那么X—>Z，多值依赖则不成立。

**6.3范式体系**

​		规范化理论：是用来设计良好的关系模式的基本理论。它通过分解关系模式来消除其中不合适的数据依赖，以解决插入异常、删除异常、更新异常和数据冗余问题。

​		范式(Normal Form)：指某个关系R(U,F)的"规范化"程度。

​		规范化：指将一个低一级范式的关系模式，通过模式分解转换为若干个高一级范式的关系模式的集合的过程。

​		1NF: 若关系模式的所有属性都是不可分的基本数据项，则该关系模式属于1NF，可记作R∈1NF。

​		2NF: 1NF关系模式如果同时满足每一个非主属性完全函数依赖于码，则该关系模式属于2NF，可记作R∈2NF。

​		3NF: 1NF关系模式的不存在非主属性对码的传递函数依赖，则该关系模式属于3NF，可记作R∈3NF，另外如果R∈3NF，则R∈2NF。即关系模式的每个非主属性既不部分依赖于码也不传递依赖于码。

​			反正法：假设存在R∈3NF，则R∉2NF，即存在部分函数依赖，假定X—>Z,其中X是码，Z是非主属性，那么一定存在一个属性组X'，X'是X的真子集，而且X'—>Z，那么X->X', X'-/->X, X'->Z.也就是Z传递依赖X.

​		BCNF: 对于R的每个函数依赖X—>Y，若Y不属于X，则X必含有候选码，那么R∈BCNF。即若一个关系模式的每一个决定因素都包含码。

**6.4逻辑蕴含与推理系统**

​	定义：关系模式R<U,F>, X,Y是U中的属性集，如果对于任何一个关系r,X—>Y都成立（即r中任意两元组t,s，若t[X] = s[Y]，则t[Y] = s[Y]）,则称F逻辑蕴含X—>Y. 记为：F|=X—>Y.

​	推理：若X—>Y ∈F，则F|=X—>Y

<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250419154937506.png" alt="image-20250419154937506" style="zoom:50%;" />

​	函数依赖闭包：

​		定义：在关系模式R<U,F>中为F所逻辑蕴含的函数依赖的全体叫作F的闭包，记为F+. F+={X—>Y | F|=X—>Y}

​	推理系统：目的，为函数依赖建立一套推理系统，实现有效的闭包F+计算。

​	构造Armstrong公理系统：设有关系模式R<U,F>，定义以下三条推理规则：

​		A1.自反律(Reflexivity): 若Y⊆X⊆U, 则X—>Y为F所蕴含。

​		A2.增广率(Augmentation): 若X—>Y为F所蕴含，且Z⊆U, 则XZ—>YZ为F所蕴含。

​		A3.传递率(Transitivity): 若X—>Y及Y—>Z为F所蕴含，则X—>Z为F所蕴含。

​	推理规则：

​		合并规则：由X—>Y，X—>Z，有X—>YZ。

​			（A2，A3）X—>YX, XY—>ZY

​		伪传递规则：由X—>Y，WY—>Z，有XW—>Z。

​			（A2，A3）XW—>YW

​		分解规则：由X—>Y及Z⊆Y，有X—>Z。

​			（A1，A3）Z⊆Y, Y—>Z

​	推理系统的正确性：

​		定理：Amstrong公理系统是有效完备的

​		有效性：推理出来的函数依赖都是对的

​		完备性：F+的每一个函数依赖，必定可以由F出发根据Armstrong公理推导出来

​	如何计算F+:

  		1. 先引入一个辅助概念 属性闭包<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250419161805820.png" alt="image-20250419161805820" style="zoom:25%;" />
  		2. 计算数学闭包<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250419161805820.png" alt="image-20250419161805820" style="zoom:25%;" />
  		3. 用构造法计算F+

​	属性X的闭包：设F为属性集U上的一组函数依赖，X⊆U，<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250419161805820.png" alt="image-20250419161805820" style="zoom:25%;" />={A|X-》A能由F根据Armstrong公理导出}，<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250419161805820.png" alt="image-20250419161805820" style="zoom:25%;" />称为属性集X关于函数依赖集F的闭包。

​	属性闭包与函数依赖闭包的关系：

​		设F为属性集U上的一组函数依赖，X, Y⊆U, X—>Y能由F根据Armstrong公理导出的充分必要条件是Y⊆<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250419161805820.png" alt="image-20250419161805820" style="zoom:25%;" />

​		将判定X—>Y⊆F+的问题，转化为判定Y⊆<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250419161805820.png" alt="image-20250419161805820" style="zoom:25%;" />的问题。

**6.5模式分解与算法**

关系模式的规范化过程是通过对关系模式的分解来实现的

​	把低一级的关系模式分级为若干个高一级的关系模式的方法并不是唯一的。

​	在这些分解方法中，只有能够保证分解后的关系模式与原关系模式等价的方法才有意义。

模式分解：将一个关系模式R<U,F>分解为若干个关系模式{R1<U1,F1>, R2<U2,F2>, ... , Rn<Un,Fn>},是指满足以下条件。不丢失也不增加

​	Fi为F在Ui上的投影, Ui⊆U

​	U=U1∪U2∪...Un

​	不存在Ui⊆Uj

分解的定义：”正确的标准“

​	具有无损连接性的模式分解(Lossless join): 若R=R1 Join R2 Join Rn; 分解不丢失数据信息

​	保持函数依赖的模式分解(Preserve dependency): 若F+ = (∪Fi)+; 分解不丢失约束信息

​	既保持无损连接性又保持函数依赖

​	无损连接性与保持函数依赖性的关系：

​		两者是相互独立的标准

​		具有无损连接性的分解不一定能够保持函数依赖

​		保持函数依赖的分解也不一定具有无损连接性

模式分解与规范化：规范化理论提供了一套完整的模式分解算法，按照这套算法可以做到：

​	若要求分解仅具有无损连接性(是指无损连接但不保持函数依赖)，那么模式分解一定能够达到4NF

​	若要求分解保持函数依赖，那么模式分解一定能够达到3NF，但不一定能够达到BCNF。

​	若要求分解既具有无损连接性，又保持函数依赖，则模式分解一定能够达到3NF,但不一定能够达到BCNF。

模式分解的正确性测试：

​	判断是否无损依赖：Chase检验法（表格法）

​		1.构建初始表格

​		2.应用函数依赖修改表格(根据函数依赖关系确定其他列)

​		3.检查是否有一行全 a

​	判断是否函数依赖：计算闭包法

​		假设R1(U1,F1), ... Rn(Un, Fn)是R(U, F)的一个分解

​		分别求F的闭包F+, Fi的闭包(U Fi)+

​		如果F+ = (U Fi)+ 那么就是保持FD的分解

**7.1数据库设计的基本步骤**

设计阶段：

​	需求分析：

​		了解与分析用户的应用需求，特别是数据和处理

​		需求分析结果一般采用数据字典来描述：

​			数据字典：系统中数据项、数据结构、数据流、数据存储和处理过程

​	概念结构设计：

​		对用户需求进行综合、归纳与抽象，形成一个独立于具体数据库管理系统的概念模型

​		通常采用E-R图来进行概念建模

​	逻辑结构设计：

​		按某种转换规则将概念结构设计转换为某个数据库管理系统所支持的数据模型，并对其进行优化

​		产出物为逻辑模式，比如关系模式

​	物理结果设计：

​		为逻辑数据库模型选取一个最适合应用环境的物理结构，包括存储结构和存取方法。

​		存储结构包括数据的存放位置和系统配置。

​		存取方法包括索引方法和聚簇方法。

​	数据库实施：

​		运用数据库管理系统提供的数据库语言及高级语言，根据逻辑结构设计和物理结构设计的结果创建数据库，编写于调试应用程序，组织数据入库并进行试运行。

​	数据库运行和维护：

​		性能监测分析、转储/恢复、安全性和完整性控制、数据库重组和重构。

​		由于应用环境在不断变化，数据库运行过程中物理存储也会不断变化，对数据库设计进行评价、调整、修改等维护工作是一项长期的任务，也是设计工作的延伸和提高。

需求分析和概念设计独立于任何数据库管理系统。

逻辑设计和物理设计于选用数据库管理系统密切相关。

数据库各级模式：

<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250419204901191.png" alt="image-20250419204901191" style="zoom:50%;" />

**7.2需求分析的任务和方法**

通过详细调查现实世界要处理的对象，充分了解原系统的工作概况，明确用户的各种需求，然后在其基础上确定新系统的功能。

通过调查、收集与分析，获得用户对数据库的如下要求：

​	1.信息要求：指用户需要从数据库中获得信息的内容与性质。由信息要求可以导出数据要求，即在数据库中需要存储哪些数据。

​	2.处理要求：指用户要完成的数据处理功能，以及对处理性能的要求。

​	3.安全性与完整性要求。

需求分析的方法：

​	调查用户需求：

​		跟班作业；开调查会；请专人介绍；询问；问卷调查；查阅记录

​	分析和表达用户需求：

​		结构化分析方法(SA)

​		基本思想是”分解“和”抽象“

​		分解：将一个复杂的系统或问题分解成若干个子系统或子问题。

​		抽象：从问题最基础的属性开始，逐步添加细节

需求分析的结果：

​	数据字典：

​		数据字典是对数据库中数据的描述，即元数据，而不是数据本身

​		通常包括数据项、数据结构、数据流、数据存储和处理过程

​	数据项：数据项是不可再分的数据单位

​		数据项描述={数据项名，数据项含义说明，别名，数据类型，长度，取值范围，取值含义，与其他数据项的逻辑关系，数据项之间的联系}

​	数据结构：反映数据项之间的组合关系

​		数据结构可以由若干个数据项或若干个数据结果组成。

​		数据结构描述={数据结构名，含义说明，组成：{数据项或数据结构}}

​	数据流：数据在系统内传输的路径

​		数据流描述={数据流名，说明，数据流来源，数据流去向，组成：{数据结构}，平均流量，高峰期流量}

​	数据存储：数据结构停留或保存的地方，也是数据流的来源和去向之一

​		数据存储描述={数据存储名，说明，编号，数入的数据流，输出的数据流，组成:{数据结构}，数据量，存储频度，存取方式}

​	处理过程：一般用判定表或判定树来描述处理过程

​		处理过程描述={处理过程名，说明，输入：{数据流}，输出：{数据流}，处理：{简要说明}}

**7.3E-R模型**

​	问题一：如何取分实体和属性

​		能作为属性对待的，尽量作为属性对待

​		实体应包含独立的属性，并可能与其他实体产生联系

​	问题二：准确描述现实应用

​	问题三：采用继承来减少冗余

​		采用继承(ISA)来简化ER图

**7.4数据模型优化**

步骤：

​	1.确定数据依赖

​	2.极小化处理，消除冗余

​	3.逐一分析，判断是否存在部分函数依赖和传递依赖

​	4.根据应用来分析是否合并或分解模式

​	5.分解关系模式(水平分解和垂直分解)

**8.1SQL语言表达能力的限制**

常见的几类难以用SQL实现的场景：

​	递归查询：

​		采用with recursive子句实现递归：

​		with recursive rs as(

​			seed query -- 初始化查询的临时结果集，记为L[1]

​			union [all]	-- 是否需要保留重复记录，加all为保留

​			recursive query  -- 执行递归查询，得到全部临时结果集，即L[2]∪...∪L[i]

​		)

​	需要系统函数支持：引入内置函数

​	包含复杂的逻辑：引入PL/SQL与存储过程/存储函数

​	需要交互功能：需要高级语言来实现

**8.2过程化SQL的例子**

例子1：通过存储过程来创建表

​	CREATE OR REPLACE PROCEDURE NewTab()

​	AS DECLARE

​	begin

​		CREATE TABLE NewTable(id int);

​	end;

​	调用存储过程：call "NewTab"()

例子2：带参数的查询函数

​	CREATE OR REPLACE FUNCTION findcustoomers(title varchar(128))

​	RETURN integer

​	AS DECLARE

​		rlt int;

​	BEGIN

​		SELECT count(*) into rlt FROM customers WHERE contact_title like title;

​		RETURN rlt;

​	END;

​	调用函数：call findcustomers('Owner');

**8.3存储过程的使用场景**

存储过程优缺点分析

例子1：对大量字符串数据进行处理

​	方法1：通过程序来完成

​	分析：若表中有大量数据，方法1将运行很长时间。

​	主要开销：

​		与数据库建立连接

​		数据库解析并执行语句

​		在数据库和程序之间传输结果

​	方法2：通过存储过程来完成

​	编写一个存储过程，实现下面的逻辑：

​		1.从表中获取所有元组

​		2.采用字符串函数来提取item ID

​		3.构造一个Insert语句并执行

​	方法2性能会有显著提升，原因在于：

​		不需要与数据库建立和撤销连接，也不用传输数据

​		存储过程只需要解析一次

例子2：在线选课系统

​	需要实现登录、选课、退课等功能

​	方法1：存储过程

​	优点：

​		速度快：不需要重复解析和优化，不需要建立与数据库的连接

​		减少网络开销：中间结果不需要通过网络传输

​		安全性更高：可更有效防范SQL注入等攻击

​	缺点：

​		调式麻烦：需要在RDBMS中编写和调试，没有IDE支持

​		破坏了程序的可移植性：在一个RDBMS中编写的存储过程不能用于另一个RDBMS

​		表达能力不如高级语言：虽然有选择循环等能力，但功能不如高级语言丰富

**8.4JDBC架构与工作原理**

1.JDBC简介

​	JDBC: Java Database Connectivity

​	一组JavaAPI来连接数据库并执行查询

​	特点：

​		可移植性，为一个RDBMS编写的代码可以很方便地用于另一个RDBMS

​		支持同时访问多个数据源

2.JDBC的架构

<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250420101246134.png" alt="image-20250420101246134" style="zoom:50%;" />

3.JDBC接口介绍

4.示例代码

5.数据库连接池

​	建立数据库连接将耗费不少系统资源，没必要每次处理完请求就把连接丢弃

​	单个连接可被不同请求重复使用

​	数据库连接池维护一个list

​		包含多个连接（可用 or 被占用）

​		每次有新的请求，从list中选取一个可用的连接

​		请求结束后，将连接回收（标记为可用）

​	连接池可以自己实现，并且高版本的jdbc已经支持

**9.1关系数据库的组织方式**

关系数据库特点：存储结构和存取路径对用户屏蔽

了解数据组织方式：

​	更好地理解关系数据库查询优化的原理

​	在应用开发中更好地进行数据库物理设计

数据组织的目标：以最优的形式在外存上组织、存放庞大数据集

​	最优：

​		存储效率高，节省存储空间

​		存取效率高，速度快，代价小

数据存储的管理方式：

​	方式一：每个DB对象对应一个操作系统文件

​		例如： PostgreSQL, Kingbase ES

​	方式二: 整个DB对应一个或若干个文件（段页式）

​		例如：Oracle, SQL Server

数据库的逻辑组织方式：以方式二来说明

​	表空间——段——分区——数据块

​		<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250420103032549.png" alt="image-20250420103032549" style="zoom:50%;" />

​		表空间：

​			对应磁盘上一个或多个物理数据文件

​			可以有多个表空间，逻辑地和物理地组织数据库中的数据存储

​			系统表空间、联机表空间、脱机表空间、永久表空间、临时表空间

​		段：

​			由多个分区组成

​			数据段、索引段、LONG段、回滚段、临时段等

​		分区：

​			由一组连续的数据块组成

​		数据块;

​			数据块是磁盘存取单元

​			数据块的大小必须等于服务器操作系统块的大小或倍数

数据库的物理组织方式：

​	文件——块——记录

​	文件：操作系统文件

​	块：

​		每个文件物理上分成定长的存储单元，即操作系统单得物理块

​		存储分配和I/O的基本单元

​	记录：物理块中存放的多条元组

逻辑组织与物理组织的对应关系：

​	<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250420103812280.png" alt="image-20250420103812280" style="zoom:50%;" />

**9.2多表聚簇存放方式**

关系表的组织

​	关系表的5种存放方式：

​		堆存放方式

​		顺序存放方式

​		多表聚簇存放方式(与其它方式不同)

​		B+树存放方式

​		哈希存放方式

多表聚簇存放方式：不同表的元组聚簇存放在同一个组块中

​	如何聚簇？

​	通过主外码参照关系进行聚簇存放

<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250420104447088.png" alt="image-20250420104447088" style="zoom:50%;" />

​	为什么聚簇？

​		优势：减少连接操作带来的开销

​		劣势：

​			降低某些查询的查询效率（同一表中的元组会分散在更多块中）

​			在更新操作时会带来更频繁的数据迁移

​	适用场景：

​		以聚簇表连接查询为主

​		较少更新

**9.3顺序表的索引**

索引的好处：

​	表的索引块数量通常比数据块数量少得多

​	可以有高效得方法快速查找索引块

​	若索引文件足够小，可长期驻留内存缓冲区，较少I/O操作

但索引会带来额外的开销

​	建立；存储；维护

顺序表索引：

​	在顺序表的排序属性上建立索引

​	也称作主索引或聚簇索引

顺序表索引类型：

​	稠密索引(Dense Index): 索引块中存放每条记录的索引属性值以及指向相应记录的指针

​		借助稠密索引的查找可减少I/O

​		有序索引，利用二分查找法在稠密索引查找指定索引项

​	稀疏索引: 基本表的每个物理存储块只对应一个索引项

​		优势1：尺寸小于稠密索引

​		优势2：索引维护代价较小

​	多级索引：解决索引尺寸大问题

​		索引建立：

​			第一级索引是稠密或稀疏索引

​			第二级及以上为建立在上一级索引上的稀疏索引

​			重复直到尺寸合适

**9.4B+树索引**

解决大型索引的组织和维护

查找效率高、按不同值查找性能平衡、易于维护等

B+树索引的结构：

​	本质是一个多级索引

​	将索引块组织成一颗平衡树（从树根到树叶的所有路径一样长）

​	三类结点: 

​		根结点：只有一个

​		中间结点

​		叶节点

​		根结点与中间结点统称为非叶结点

​	B+树的秩：一个索引块最多能存放的指针的个数

​	一棵秩为n的B+树索引:

​		每个结点最多包含n-1个key

​		除了根结点外，每个结点最少包含[(n-1)/2]个key(根结点最少含有一项)

​		含有j-1项的非叶结点，有j个指针，分别指向其j个孩子(叶结点除外，它没有孩子)

​		所有的叶结点都在同一级上。含有j-1项的叶结点，有j个指针，前j-1个指针指向相应的关系表元组，第j个指针指向兄第叶结点

B+树索引的查询：

​	随机查找：按照索引属性的取值进行查找

​		从根结点开始

​		沿父子结点指针逐层向下搜索

​		直到叶结点(匹配则返回结果，否则没有满足条件的元组)

​	范围查找：

​		用随机查找的方法分别找到范围条件的入口点和结束点

​		对入口点和结束点之间的属性值进行顺序搜索

​	无论查询条件中的属性值是什么，查询效率都相似

B+树索引的维护：

​	维护B+树索引的关键是维持B+树的平衡特性

​		插入元组:

​			情况1：叶结点有空闲空间（key值个数小于n-1）

​				直接插入

​			情况2：叶结点达到最大充满度（key值个数等于n-1）

​				当前叶结点分裂成2个叶结点

​				父结点插入

​				维护父结点

​				逐层向上，直到插入完成

​			若根结点分裂会导致树的高度增加一层

​		删除元组：

​			用随机搜索算法找到要删除的索引项

​			情况1：删除后叶结点仍能满足最小充满度(Key值个数大于[(n-1)/2]向上取整)

​				直接删除

​			情况2：删除后叶结点不能满足最小充满度(Key值个数小于等于 [(n-1)/2]向上取整)

​				删除当前索引项

​				合并叶结点

​				删除父结点索引项

​				维护父结点

​				逐层向上，直到删除完成

​			若合并传递至根结点会导致树的高度降低一层

**9.5哈希索引**

两个关键要素

​	哈希表：

​		B个哈希桶

​		每个桶存放一条或多条哈希值相同的索引项

​	哈希函数

​		将记录的索引属性值映射到哈希桶

静态哈希索引：

​	哈希函数：

​		设计原则——尽量保证函数的取值随机和均匀

​			不会出现某个桶的索引项远远超过其它桶

​	哈希表：

​		构成——由一组桶组成，一个桶对应一个或多个物理块

​		构成——桶中存放被映射到该桶的哈希索引项

​		构成——每条索引项包括索引属性值和指向相应记录的指针

​		桶溢出的三类主要原因：

​			哈希桶数量不足，不能存放所有的索引项

​			属性存在偏斜，某些属性值过多

​			哈希函数设计不合理，无法将索引均匀地映射到每个桶，导致某个桶的数据过多

​			解决措施——较少桶溢出：预留一定百分比的空间

​			解决措施——补救桶溢出：分配溢出桶

​				当溢出桶空间充满时，追加新的溢出桶

​				用溢出链将一个桶及其溢出桶链接在一起

​	哈希索引的查找及维护：

​		擅长做等值查找：

​			根据属性值计算出哈希函数值，得到桶号

​			到相应的桶中搜索相应的索引项

​			若桶中没有找到，但存在溢出桶，继续搜索溢出桶

​		插入元组时，需向哈希索引中插入相应的索引项

​			哈希函数计算桶号：

​				若桶中有空间，直接插入

​				若溢出桶有空间，直接插入

​				若已满，申请新的溢出桶并插入

​		删除元组时，需删除相应的索引项：

​			哈希函数计算桶号：

​				若没有溢出桶 ，直接删除

​				若有溢出桶，判断是否有空间合并溢出桶

动态哈希索引：

静态哈希索引中，桶的个数事先确定且不再改变

​		桶溢出不可避免，影响查找效率

解决方法1——适当预留桶空间

​	表数据量难以估算

解决方法2——随着关系表的增大，周期性地增加哈希桶数目，并重组索引

​	耗时，影响正在进行的查询		

随着关系表的增大/缩小，逐渐扩大/减少桶的数目

两类动态哈希索引:

​	可扩展哈希索引

​	线性哈希索引

**10.1查询处理步骤**

<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250420161638308.png" alt="image-20250420161638308" style="zoom:50%;" />

1.查询分析

​	词法分析：从查询语句中识别出正确的语言符号

​	语法分析：进行语法检查

2.查询检查

​	语义分析：

​		检查关系的适用

​		检查与解析属性的适用

​		检查类型

​	安全性检查：

​		用户时所访问对象属主

​		用户不是所访问的对象的属主

​	完整性初步检查：检查不依赖现有数据库数据的静态完整性约束

​	视图转换：

​		视图消解：把对视图的访问转换为对导出这个视图的基本表的访问

​		实体化视图：将视图实体化为临时表，用到视图的地方，都用该临时表替换。

​	查询树(query tree)：

​		查询检查完成后把SQL查询语句转换成内部表示，即等价的关系代数表达式。

​		关系数据库管理系统一般都用查询树，也称为语法分析树来表示扩展的关系代数表达式。

3.查询优化：选择一个高效的查询处理策略

​	查询优化分类：

​		代数优化/逻辑优化：指关系代数表达式的优化

​		物理优化：指存取路径和底层操作算法的选择

​	查询优化的选择依据：

​		基于规则

​		基于代价

​		基于语义

​	查询执行计划：依据优化器得到的执行策略生成查询执行计划

4.查询执行

​	代码生成器生成执行查询计划的代码

​	执行方法1——自顶向下

​	执行方法2——自底向上

**10.2连接操作算法**

1.嵌套循环连接

2.排序—合并连接：只能做等值连接

​	先对表进行排序，后进行合并连接

3.索引连接：

​	要求其中一个参与连接的表已经建立好索引

4.哈希连接：把连接属性作业hash码，用同一个hash函数把student表和sc表中的元组散列到hash表中

​	划分阶段：

​		对包含较少元组的表进行一遍处理

​		把它的元组按hash函数分散到hash表的桶中

​	试探阶段：

​		对另一个表进行一遍处理

​		把sc表的元组也按同一个hash函数进行散列

​		把sc元组与桶中来自student表并与之相匹配的元组连接起来

**10.3物理优化**

基于规则的启发式优化：这些启发式规则在大多数情况下适用，但不是在每种情况下都适用

​	优点—简单

​	缺点—优化效果可能不理想

选择操作的启发式规则：	

​	对于小关系，适用全表顺序扫描，即使选择列上有索引

​	对于大关系，启发式规则有：

​		1.对于选择条件是"主码=值"的查询

​			查询结果最多是一个元组，可以选择主码索引

​		2.对于选择条件是"非唯一值属性=值"的查询，且选择列上有索引

​			要估算查询结果的元组数目

​			如果比例较小(<10%)可以适用索引扫描方法

​			否则还是使用全表顺序扫描

​		3.对于选择条件是属性上的非等值查询或者范围查询，并且选择列上有索引

​			估算查询结果的元组数目

​			如果比例较小(<10%)可以使用索引扫描方法

​			否则还是使用全表顺序扫描

​		4.对于用OR连接的析取选择条件

​			如果均为等值条件，且涉及的所有属性上都有普通索引，可以用索引扫描方法

​				通过分别查找满足每个条件的指针，求指针的并集

​			其他情况：使用全表顺序扫描

​		5.对于用AND连接的合取选择条件

​			如果有涉及这些属性的组合索引

​				优先采用组合索引扫描方法

​			如果某些属性上有普通索引，可以用索引扫描方法

​				通过分别查找满足每个条件的指针，求指针的交集

​				通过索引查找满足部分条件的元组，然后再扫描这些元组时判断是否满足剩余条件

​			其他情况：使用全表顺序扫描

连接操作的启发式规则：

​	1.如果两个表都已经按照连接属性排序

​		选用排序-合并算法

​	2.如果一个表再连接属性上有索引

​		选用索引连接算法

​	3.如果上面2个规则都不适用，其中一个表较小

​		选用哈希算法

​	4.其他情况可以选用嵌套循环方法，并选择其中较小的表作为外表

基于代价估算的优化

​	关系数据库管理系统通过某种代价模型计算出各种查询执行策略的执行代价，然后选取代价最小的执行方案

​	步骤1——由逻辑计划派生出多个不同的物理计划

​	步骤2——对每个物理计划评估其代价

​	步骤3——选择具有最小估计代价的物理查询计划

​	物理优化的搜索空间非纯庞大

​	以连接为例——两表连接：树形只有一种

​			<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250420173923921.png" alt="image-20250420173923921" style="zoom:25%;" />

​	以连接为例——四表连接：可能的树形状有5种

​			<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250420174027543.png" alt="image-20250420174027543" style="zoom:25%;" />

​		左深树；浓密树；右深树；Zig-zag 树

​		每种树形状有4! = 24 种排序次序

​		四表连接查询树共有5*24=120种形式

​		每个连接操作结点假设有4种算法可选择，则可得到4^3*120=7680种查询执行计划

​	以连接为例——N表连接

​		树形状的数目T(n)<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250420175208502.png" alt="image-20250420175208502" style="zoom:25%;" />

​		树形的分配关系n!

​		每个操作符结点可能有m种算法可供选择

​		N表连接的查询执行计划数=m^(n-1) * T(n)

两者结合的优化方法

​	用启发式规则裁剪搜索空间

​		第一类——限制查询计划树形状的规则（例如：限制为左深连接 树）：T(n) = 1

​		第二类——选择连接顺序的启发式规则（按大小排序，依次连接）：n! = 1

​		第三类——选取操作算法的启发式规则（有索引采用索引连接，按树形排好序用排序-合并连接）：m^(n-1)  = 1

​	用启发式规则选择入口点：

​		典型算法1——分支界定计划枚举

​		典型算法2——爬山法

**10.4查询执行**

自顶向下: 系统将反复向根结点的投影操作发出需求元组的请求

​		<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250420180511565.png" alt="image-20250420180511565" style="zoom:50%;" />

自底向上：各操作符不需要等待元组请求，而是积极主动地产生元组

​		<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250420180706381.png" alt="image-20250420180706381" style="zoom:50%;" />

​		操作符的调度:

​			DBMS自己调度：依据缓存区的填充情况

​			交给OS调度：OS依据分时机制来调度，依据缓冲区填充情况进行调整

两种执行方式的比较:

​	执行方式：Push与Pull

​	自底向上的执行方式可以看成将数据从一颗操作符树的底层推（push）上的过程

​	而自顶向下的执行方式可看成是从树顶将数据拉（pull）上来的过程

​	产生元组：Active与Lazy

​	在自底向上的执行方式种，元组的产生是积极的

​	而在自顶向下的执行方式中，元组消极地按需产生

**11.1事物的基本概念**

1.为什么需要事务

​	事务时数据库管理系统保证各类故障、多用户高并发访问下数据不出错的关键技术

2.什么是事务

​	事务时用户定义的一个数据库操作序列，这些操作要么全做，要么不做，是一个不可分割的工作单位。

​	事务和程序是两个概念：

​		一个事务可以是一条SQL语句，一组SQL语句或整个程序

​		一个程序通常包含多个事务

​	定义事务：

​		显示方式:

​		BEGIN TRANSACTION

​		SQL 语句1

​		SQL 语句2

​		COMMIT -- 事务正常结束

​		BEGIN TRANSACTION

​		SQL 语句1

​		SQL 语句2

​		ROLLBACK -- 事务异常终止，已完成的操作全部撤销，事务回滚到开始状态

​		隐式方式：

​		当用户没有显式地定义事务时，数据库管理系统按缺省规定自动划分事务

3.如何实现事务机制

事务的ACID特性

​	原子性(Atomicity): 事务对数据库状态的修改要么全部执行，要么全部不执行。

​	一致性(Consistency): 事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。

​		确保完整性约束不被破坏

​		一致性是指事物提交后数据在数据库中的状态

​	隔离性(Isolation): 一个事务的执行不能被其他事务干扰。

​	持续性(Durability): 一个事务一旦提交，它对数据库中数据的改变就应该是永久的。

事务实现的关键技术：

​	系统故障恢复技术：保证事务的原子性A和持续性D

​	并发控制技术：保证事务的一致性C和隔离性

**11.2故障恢复的基本原理**

1.数据库故障问题的深入分析

​	数据库故障产生的原因

​		计算机硬件故障

​		软件的错误

​		操作员的失误

​		恶意的破坏

​	故障的影响

​		运行事务非正常中断，影响数据库中数据的正确性(破坏了事务的原子性)

​		破坏数据库，全部或部分丢失数据(破坏了事务的持续性和原子性)

2.数据库故障的分类

​	事务内部的故障

​		有的是可以通过事务程序本身发现的

​		有的是非预期的，不能由事务程序处理的

​	系统故障

​		称为软故障，是指造成系统停止运转的任何事件，使得系统要重新启动。

​		特定类型的硬件错误(如CPU故障)

​		操作系统故障

​		数据库管理系统代码错误

​		系统断电

​		系统故障的影响：

​			整个系统的正常运行突然被破坏

​			所有正常运行的事务都非正常终止

​			内存中数据库缓存区的信息全部丢失

​			不破坏数据库

​	介质故障

​		戒指故障称为硬故障，指外存故障

​			磁盘损坏，磁头碰撞、瞬时强磁场干扰

​		介质故障破坏数据库或部分数据库，并影响正在存取着部分数据的所有事务

​		介质故障比前两类故障的可能性小得多，但破坏性大得多

3.数据库恢复的基本原理

定义：

​	数据库管理系统必须具有把数据库从错误状态恢复到某一已知的正确状态的功能，这就是数据库的恢复管理系统对故障的对策

​	恢复子系统是数据库管理系统的一个重要组成部分

​	恢复技术是衡量系统优劣的重要指标

对于不同故障的恢复策略

​	1.事务内部故障的恢复

​		事务故障意味着：

​			事务没有达到预期的终点（COMMIT或显式的ROLLBACK）

​			数据库可能处于不正确状态

​		事务故障的恢复：事务撤销（UNDO）

​		 	强行回滚（ROLLBACK）该事务

​		撤销该事务已经作出的任何对数据库的修改，使得该事务象根本没有启动一样

​	2.系统故障的恢复

​		发生系统故障时，一些尚未完成的事务的结果可能已送入物理数据库，造成数据库可能处于不正确状态。

​		恢复策略：系统重新启动时，恢复程序让所有非正常终止的事务回滚，强行撤销（UNDO）所有未完成事务

​		发生系统故障时，有些已完成的事务可能有一部分甚至全部留在缓冲区，尚未写回到磁盘上的物理数据库中，系统故障使得这些事务对数据库的修改部分或全部丢失

​		恢复策略：系统重新启动时，恢复程序需要重做（REDO）所有已提交的事务

​	系统故障的恢复需要做两件事：

​		撤销所有未完成的事务

​		重做所有已提交的事务

​	3.介质故障的恢复 

​		重载备份

​		重做已经提交的事务

**11.3基于备份与日志恢复策略**

数据库恢复的基本技术：

​	日志技术：针对事务故障&系统故障

​	什么事日志文件：日志文件是用来记录事务对数据库的更新操作的文件

​	日志文件的格式：

​		以记录为单位的日志文件

​		以数据块为单位的日志文件

​	日志文件内容：

​		各个事务的开始标记（BEGIN TRANSACTION）

​		各个事务的结束标记（COMMIT或ROLLBACK）

​		各个事务的所有更新操作：

​			事务标识、操作类型、操作对象、更新前数据的旧值、更新后数据的新值等

​		日志文件的分类：

​			undo日志：记录旧值，先写日志，后写数据，最后写提交标记

​			redo日志：记录新值，先写日志和提交标记，后写数据

​			undo/redo日志：记录旧值和新值，先写日志，后写数据

​	数据备份：针对介质故障

​		什么是备份：备份时指DBA定期地将整个数据库复制到磁带、磁盘或其他存储介质上保存起来的过程。这些备份的数据或日志称为后备副本或后援副本

​		备份的作用：数据库遭到破坏或发生介质故障后可以将后备副本重新装入，从而恢复到备份时的状态

​		备份方法：

​			静态备份：在系统中无运行事务时进行的备份操作。

​				备份开始时数据库处于一致性状态

​				备份期间不允许对数据库的任何存取、修改活动，得到的一定时一个数据一致性的副本

​				优点：实现简单

​				缺点：降低了数据库的可用性

​					备份必须等待正运行的用户事务结束

​					新的事务必须等备份结束

​			动态备份：备份操作与用户事务并发进行

​				备份期间允许对数据库进行存取或修改

​				利用动态转储得到的后备副本进行故障恢复

​				优点：不用等待正在运行的用户事务结束，且不会影响新事物的运行

​				缺点：单纯依靠后备副本无法保证数据正确有效

​			全量备份：每次备份全部数据库

​			增量备份：只备份上次备份后更新过的数据

​			全量备份与增量备份比较:

​				从恢复角度看，使用全量备份得到的后备副本进行恢复往往更方便

​				如果数据库很大，事物处理又十分频繁，则增量备份方式更使用更有效

数据库恢复的策略：

​	事务故障的恢复：

​		事务故障：事务在运行至正常终止点前被终止

​		恢复方法：由恢复子系统利用日志文件撤销此事务以对数据库进行的修改

​		事务故障的恢复由系统自动完成，对用户时透明的，不需要用户干预

​	系统故障的恢复：

​		系统故障：

​			未完成事务对数据库的更新可能已写入数据库

​			已提交事务对数据库的更新可能还留在缓冲区没来得及写入数据库

​		恢复方法：

​			撤销故障发生时未完成的事务

​			重做已完成的事务

​		系统故障的恢复由系统在重新启动时自动完成，不需要用户干预

​	介质故障的恢复:

​		介质故障:由于硬件的可靠性较差而出现的存储介质发生物理损坏，造成数据库的数据全部或部分丢失

​		恢复方法：

​			重装数据库

​			重做已完成的事务

**11.4基于检查点的恢复策略**

1.问题的提出

​	几个问题：

​		搜索整个日志将耗费大量的时间

​		重做处理：重新执行，浪费了大量时间

​		日志越来越庞大，总有一天会耗尽磁盘空间

2.检查点技术

​	具有检查点的恢复技术

​	目标：将已提交事务的更新Flush到磁盘上

​	技术点：如何识别已提交事务

​		在日志文件中增加检查点记录，标记已提交事务

​		让系统快速找到最新的检查记录

​	检查点记录的内容：

​		建立检查点时刻所有正在执行的事务清单

​		这些事务最近一个日志记录的地址

​	重新开始文件的内容：

​		记录各个检查点记录在日志文件中的地址

​	维护包含检查点的日志的方法:

​		周期性地执行如下操作：建立检查点，保存数据库状态。

​	建立检查点的时间：

​		恢复子系统可以定期或不定期地建立检查点，保存数据库状态

​		定期：按照预定的一个时间间隔，如每隔一小时建立一个检查点

​		不定期：按照某种规则，如日志文件已写满一半建立一个检查点

3.利用检查点的恢复策略

​	事务的恢复：

​		当事务T在一个检查点之前提交

​		当事务T在检查点时还没有完成

​	利用检查点的恢复步骤：

​		1.从重新开始文件中找到最后一个检查点记录在日志文件中的地址，由该地址在日志文件中找到最后一个检查点记录

​		2.由该检查点记录得到检查点建立时刻所有正在执行的事务清单ACTIVE-LIST

​			建立两个事务队列：

​				UNDO-LIST

​				REDO-LIST

​			把ACTIVE-LIST暂时放入UNDO-LIST队列，REDO队列暂为空

​		3.从检查点开始正向扫描日志文件，直到日志文件结束

​			有新开始的事务放入UNDO-LIST队列

​			有提交的事务，从UNDO-LIST队列移到REDO-LIST队列；

​			直到日志文件结束

​		4.对UNDO-LIST中的每个事务执行UNDO操作

​			对REDO-LIST中的每个事务执行REDO操作

**12.1数据异常与隔离级别**

1.事务的执行模型

2.数据异常及其形式化

​	脏写：事务中未提交修改被另一个事务覆盖了

<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250421205352015.png" alt="image-20250421205352015" style="zoom:50%;" />

​	脏读：事务会读取到一个未提交的值

<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250421205443099.png" alt="image-20250421205443099" style="zoom:50%;" />

​	不可重复读：一个事务两次读取相同账户的余额不同

<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250421205519440.png" alt="image-20250421205519440" style="zoom:50%;" />

​	幻读：一个事务执行的两次基于相同谓词的查询操作获得的结果不同	

<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250421205545792.png" alt="image-20250421205545792" style="zoom:50%;" />

3.数据异常与隔离级别

​	隔离级别：

​	读未提交（Read Uncommitted）

​	读已提交（Read Committed）

​	可重复读（Repeatable Read）

​	可串行化（Serializable）

​	一般情况下，隔离级别越高，则性能越弱

<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250421204938884.png" alt="image-20250421204938884" style="zoom:50%;" />

**12.2封锁与封锁协议**

1.为什么需要封锁

​	数据异常可能会使得数据库中的数据或上层的应用逻辑处于不正确的状态

​	封锁是最常用的一种消除数据异常的方法

​	封锁的目标：

​		消除特定类型的数据异常

​		消除所有的数据异常

2.什么是封锁

​	封锁就是事务T在对某个数据对象操作之前，先向系统发出请求，对其加锁

​	加锁后事务T就对该数据对象有了一定的控制，在事务T释放它的锁之前，其它的事务不能更新此数据对象。

​	封锁是实现并发控制的一个非常重要的技术

​	基本封锁类型：

​		排它锁（Exclusive Locks, 简记为X锁）又称写锁，若事务T对数据对象x加上X锁，则只允许T读取和修改x,其它任何事务都不能再对x加任何类型的锁，直到T释放x上的锁。保证其它事务在T释放x上的锁之前不能再读取和修改x

​		共享锁（Share Locks, 简记为S锁）又称读锁，若事务T对数据对象x加上S锁，则事务T可以读x但不能修改x，其它事务只能再对x加S锁，而不能加X锁，直到T释放x上的S锁。保证其它事务可以读x，但再T释放x上的S锁之前不能对A做任何修改

3.怎么封锁-封锁协议

​	什么是封锁协议:

​		在运用X锁和S锁对数据对象加锁时，需要约定一些规则，这些规则为封锁协议。

​		对封锁方式规定不同的规则，就形成了各种不同的封锁协议，它们分别在不同的程度上为并发操作的正确调度提供一定的保证。

​	三级封锁协议：

​		一级封锁协议：在事务T在修改数据x之前必须先对其加X锁，直到事务结束才释放。

​			只有长写锁

​				一级封锁协议可防止脏读，并保证事务T是可恢复的。

​				在一级封锁协议中，如果仅仅是读数据不对其进行修改，是不需要加锁的，所以它不能保证可重复读和不读“脏”数据。

​		二级封锁协议：一级封锁协议加上事务T在读取数据x之前必须先对其加S锁，读完后即可释放S锁。

​			长写锁：一级封锁协议

​			短读锁：数据x读之前加读锁，读完后即可释放锁

​			二级封锁协议可以防止脏读和读“脏”数据

​			在二级封锁协议中，由于读完数据后即可释放S锁，所以它不能保证可重复读。

​		三级封锁协议：一级封锁协议加上事务T在读取数据x之前必须先对其加S锁，直到事务结束才释放。

​			长读锁

​			长写锁

​			三级封锁协议可以防止脏写、读脏数据和不可重复读。

<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250421212443063.png" alt="image-20250421212443063" style="zoom:50%;" />

**12.3可串行化与冲突可串行化**

1.什么是正确的调度-可串行化调度

​	事务的调度：给定一组事务，其包含操作的执行顺序称为这组事务的调度。

​	并发事务：给定任意两个事务，如果它们在执行时间上有重叠，且存在数据库中的某一个数据项，其中一个事务写该数据项，另一个事务读或写该数据项，则称这两个事务时并发事务。 

​	串行调度是正确的调度

​	串行调度：如果在一个调度中，只有当上一个事务运行结束之后，才会开启下一个事务，那么这个调度被称为串行调度

​	可串行化调度：对于多个并发执行的事务的调度，当且仅当其结果与按某一次序串行执行这些事务时的结果相同，这种调度策略称为可串行化调度。

​	可串行性：

​		是并发事务正确调度的准则；

​		一个给定的并发调度，当且仅当它是可串行化的，才认为是正确调度。

2.可串行化调度存在的问题

​	资源利用率底

​	解决串行调度的方法：并发执行事务，提高资源利用率

​	如何判断一组事务的实际执行时可串行化：

​		枚举该组事务所有可能的串行执行结果

​		按照该组事务的实际执行，获得该组事务执行后数据库的状态

​		比较该组事务执行后数据库的状态&每一个串行执行结果，如果其中有一个符合，则说明该组事务的实际执行时可串行化

​	复杂度太高

​	可串行化调度只有理论上的价值，无法用于指导实际系统的设计

3.实际系统中使用的正确调度-冲突可串行化调度

​	冲突操作：

​		冲突操作指的是属于不同事务的操作对相同的数据项进行读写操作或写写操作。

​		冲突操作要求两个操作中至少有一个为写操作，如R1(x)W2(x)为冲突操作，但R1(x)R2(x)不是冲突操作

​	冲突可串行化调度：如果一个调度S通过交换某些非冲突操作的顺序得到调度S’，那么调度S和调度S'是冲突等价的。如果一个调度S'是冲突等价于一个串行调度S的，那么调度S‘是冲突可串行化调度。

​	不能交换的操作：

​		同一个事物的两个操作

​		不同事务的冲突操作

​	剩余的操作，两两之间是可以交换的

​	冲突可串行化调度是可串行化调度的充分条件，不是必要条件。

​	除了基于等价交换的冲突可串行化检测，常用的冲突可串行化调度判定还有基于事务依赖图的方法。

**12.4两阶段封锁协议**

1.什么是两阶段封锁协议

​	数据库管理系统普遍采用两阶段锁协议的方法实现并发调度的可串行性，从而保证调度的正确性

​	两段锁协议：指所有事务必须分两个阶段对数据项加锁和解锁

​		在对任何数据进行读、写操作之前，事务首先要获得对该数据的封锁

​		在释放一个封锁之后，事务不再申请和获得任何其它封锁

​	“两段”锁的含义--事务分为两个阶段

​		第一阶段是获得封锁，也称为扩展阶段：事务可以申请获得任何数据项上的任何类型的锁，但是不能释放任何锁

​		第二阶段是释放锁，也称为收缩阶段：事务可以释放任何数据项上的任何类型的锁，但是不能再申请任何锁

2.两阶段封锁协议于冲突可串行化调度

​	基于事务依赖图的冲突可串行化定义

​	定理：给定一组事务，如果每个事务的执行都遵守两阶段封锁协议，则该组事务的执行一定是冲突可串行化的。

​	背后的原理：每个事务的执行都遵守两阶段封锁协议，则该调度对应的事务依赖图中一定不存在环。

​	事务遵守两段锁协议是可串行化调度的充分条件，而不是必要条件

3.两阶段封锁协议存在的问题及解决办法

​	问题1：死锁

​	解决办法：

​		事前：死锁预防

​			No-Wait(发生冲突就回滚)

​			Wait-Die(优先级高的事务等待优先级低的事务)

​			Wound-Wait(优先级低的事务等待优先级高的事务)

​		事后：死锁检测

​	问题2：级联回滚

​		严格两阶段封锁协议

​		强严格两阶段封锁协议

**13.1数据库管理系统的系统架构**

RDBMS层次结构示例：

<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250422215119180.png" alt="image-20250422215119180" style="zoom:50%;" />

​	应用层：RDBMS与用户/应用程序的接口

​	语言处理层：处理SQL，生成可执行代码

<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250422215137264.png" alt="image-20250422215137264" style="zoom:50%;" />

​		词语分析：词法分析和语法分析，生成语法树

​		语义检查/视图转换：

​			语义是否正确

​			完整性检查

​			视图消解

​		查询优化：

​			代数优化

​			物理优化

​	数据存取层：将集合操作转换为单记录操作

<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250422215158599.png" alt="image-20250422215158599" style="zoom:50%;" />

​		调用存储器，提供元组操作接口：

​			单个元组的查、增、删、改

​			元组存取路径维护

​			元组和存取路径的封锁、解锁

​			日志文件登记和读取

​	数据存储层：缓冲区管理和文件操作

<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250422215218628.png" alt="image-20250422215218628" style="zoom:50%;" />

​		缓冲区管理：

​			RDBMS-系统缓冲区-外存

​			淘汰算法是缓冲区管理的核心，例如FIFO，LRU

​		内外存交换

​		外存管理

​	数据库：存储数据、索引及日志等数据库对象

**13.2关系数据库管理系统的运行过程示例**

<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250422215907840.png" alt="image-20250422215907840" style="zoom:50%;" />

**13.3数据存取层的系统架构**

<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250422220122433.png" alt="image-20250422220122433" style="zoom:50%;" />

记录存取、事务管理子模块：

​	只在数据的逻辑结构上操作

​	记录存取子系统:

​		按某个属性值读取一个元组

​		顺序取一个元组

​		按已选定的某个逻辑存取路径进行

​	事务管理子系统：

​		定义和控制事务

​		记入日志文件

控制信息管理模块：

​	登记不同记录类型

​	登记不同存取路径的说明信息和控制信息

​	和记录存取、事务管理子系统一起保证事务的正常运行

​	提供对数据字典中说明信息的读取、增加、删除和修改操作

排序/合并子系统：

​	得到用户要求的有序输出：ORDER BY

​	加速关系运算的中间步骤：

​		数据预处理，例如连接操作有时需要先做排序

​		动态建立索引

​		将随机读取数据转为顺序读取，提升效率

存取路径维护子系统：

​	更新数据时，经常需要维护相应的存取结构

​	例如B+树索引的动态维护

封锁子系统：

<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250422220936715.png" alt="image-20250422220936715" style="zoom:50%;" />

日志登记子系统：

​	维护日志记录，支持事务和数据恢复

​	主要操作：

​		写日志记录

​		读日志记录

​		扫描日志文件

​		撤销事务

​		重做事务

**13.3缓冲区管理**

<img src="F:\LearnDoc\1-架构师-20250406\2-数据库\数据库概论.assets\image-20250422221156277.png" alt="image-20250422221156277" style="zoom:50%;" />

RDBMS利用系统缓冲区缓存数据

数据存取层读取数据时均需通过系统缓冲区

缓冲区包含多个定长页面

读数据流程：

​	首先在缓冲区中根据ID查找页面

​	若找到，跳到最后一步

​	否则，从外存读入指定页面，装载入缓冲区

​	注意，若缓冲区满，还需要淘汰某个页面

​	最后，将该页面在缓冲区位置返回给程序

写数据流程：

​	更新缓冲区中对应的页面

​	标记页面

​	在适当时候写入到外存

​		页面被淘汰，移到外存

​		其它写策略，比如强制写盘

页面淘汰：

​	缓冲区常驻内存，通常远小于数据库

​	当缓冲区已满，且需要读入新的页面时，需要将部分页面移出

​	若被移出页面被更改过，需要写入外存

​	页面淘汰算法是缓冲区管理核心技术，其目标在于尽量减少IO
