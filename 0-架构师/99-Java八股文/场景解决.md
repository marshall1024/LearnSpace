#### 百万数据导出excel，解决OOM

试验准备：

1.手动生成100000数据

2.设置最大运行内存为1g

3.使用EasyPOI工具导出-单线程

4.执行导出，使用Java VisualVM工具查看老年代(OLD)内存会爆满，出现OOM

5.解决方式，使用多线程分批次导出

#### 如何定位线上OOM

**1.造成OOM的原因**

​	a.一次性申请的数据太多

​		更改申请对象数量

​	b.内存资源耗尽未释放

​		找到未释放的对象进行释放

​	c.本身资源不够

​		jmap -heap 查看堆信息

​		试验过程：

​		a. 执行应用	java -jar jvm-demo.jar &

​		b. 查看堆信息	jmap -heap 进程id

**2.如何快速定位OOM**

a.系统已经OOM挂了

提前设置-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=指定目录

b.系统运行中还未OOM

导出dump文件:jmap -dump:format=b,file=xushu.hprof 进程id

或使用Arthas工具

c.结合jvisualvm进程调试

查看最多跟业务有关对象—>找到GCRoot—>查看线程栈

#### 线上突发cpu飙高怎么定位和解决

1.top命令：找到cpu占用最高的进程PID

2.top -H -p 进程PID找到cpu占用最高的线程ID

3.printf '0x%x\n' 线程id 命令将线程ID转换为16进制

4.jstack 进程PID|grep 16进制线程PID -A 20

#### 如何定位&避免死锁

死锁原因：并发下线程因为相互等待对方资源，导致“永久”阻塞的现象。

**定位**

1.jps命令找到死锁线程ID

2.jstack 线程ID查看死锁信息

**产生死锁的4大因素：**

互斥：共享资源只能被一个线程占用。-互斥锁

占有且等待：线程当前占有至少一个资源并还想请求其他线程持有的其他资源就会造成等待。-等待对方释放资源

不可抢占：资源只能由持有它的线程自愿释放，其他线程不可强行占有该资源。-无法释放对方资源

循环等待：线程T1等待线程T2占有的资源，线程T2等待线程T1占有的资源，就是循环等待。 -两个线程相互等待

**避免死锁**

破坏4大因素之一

#### 秒杀系统如何设计

**痛点: **激增流量 

瞬时并发量大：

大量用户会在同一时间进行抢购

网站瞬时访问流量激增

库存少：

访问请求数量远远大于库存数量

只有少部分用户能够秒杀成功

**设计图**

![image-20250712114220279](F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250712114220279.png)

**逐层解析**

**访问层-商品页**

商品页静态化，静态资源放入cdn服务器

![image-20250712114355851](F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250712114355851.png)  

![image-20250712114534257](F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250712114534257.png)

**访问层-秒杀按钮**

![image-20250712114836611](F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250712114836611.png)

**负载层-多级负载均衡&限流&自动伸缩**

![image-20250712115221313](F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250712115221313.png)

**支撑层—redis**

![image-20250712115411289](F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250712115411289.png)

**支撑层—mq**

<img src="F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250712115706784.png" alt="image-20250712115706784" style="zoom:50%;" />

**数据库**

<img src="F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250712115741444.png" alt="image-20250712115741444" style="zoom:50%;" />

#### 订单超时自动取消是怎么实现的

**JDK自带的延时队列**

优点：简单，不需要借助其他第三方组件，成本低。

缺点：

存储在内存中，每次重启需要从数据库初始化

所有超时处理订单都要加入到DelayQueue中，占用内存大

没法做到分布式处理，只能在集群中选一台leader专门处理，效率低。

不适合订单量比较大的场景。

<img src="F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250712120544592.png" alt="image-20250712120544592" style="zoom:50%;" />

**RocketMQ的定时消息**

优点：

使用简单，和使用普通消息一样。

支持分布式。

精度高，支持任意时刻。

缺点:

使用限制：定时时长最大值24小时

成本高：每个订单需要新增一个定时消息，且不会马上消费，给MQ带来很大的存储成本。

同一时刻大量消息会导致消息延迟：定时消息的实现逻辑需要先经过定时存储等待触发，定时时间到达后才会被投递给消费者。因此，如果将大量定时消息的定时时间设置为同一时刻，则到达该时刻后会有大量消息同时需要被处理，会造成系统压力过大，导致消息分发延误，影响定时精度

<img src="F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250712121056567.png" alt="image-20250712121056567" style="zoom:50%;" />

**Redis的过期监听**

缺点：

不可靠，Redis在过期通知的时候，如果应用正好重启了，那么就有可能通知事件就丢了，会导致订单一直无法关闭，有稳定性问题。如果一定要使用Redis过期监听方案，建议再通过定时任务做补偿机制。

如果订单量大需要占用中间件大量的存储空间，需要额外维护成本。

<img src="F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250712121742940.png" alt="image-20250712121742940" style="zoom:50%;" />

**定时任务分布式批处理**（阿里）

<img src="F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250712123146093.png" alt="image-20250712123146093" style="zoom:50%;" />

<img src="F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250712123718868.png" alt="image-20250712123718868" style="zoom:50%;" />

**总结**

如果对于超时精度比较高，超时时间在24小时内，且不会有峰值压力的场景，推荐使用RocketMQ的定时消息解决方案。

在电商业务下，许多订单超时场景都在24小时以上，对于超时精度没有那么敏感，并且有海量订单需要批处理，推荐使用基于定时任务的跑批解决方案。

#### 如何防止重复下单

**存在重复步骤：1.下单，会存在多条订单记录**



<img src="F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250713091134540.png" alt="image-20250713091134540" style="zoom:50%;" />

**方案一(前端)：提交订单按钮置灰**

**方案二(后端)：redis setnx**

key设置建议保持幂等性: 用户token+URL+key

设置setnx过期时间3~5s 

<img src="F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250713092441488.png" alt="image-20250713092441488" style="zoom:50%;" />

#### 怎么防止刷单

**防刷**

<img src="F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250713094702440.png" alt="image-20250713094702440" style="zoom:50%;" />

注册环节：手机验证码——手机接码验证平台

登录环节：图形验证码——打码平台

活动环节：同一IP限制（账号异常限制；囤积账号，没有交互动作新账号）

<img src="F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250713095147259.png" alt="image-20250713095147259" style="zoom:50%;" />

**业务风控**

对于羊毛党，不能避免，只能风险控制=风控部门

提高羊毛门槛：实名认证、消费门槛、随机优惠

限制用户参与、中奖、奖励次数

根据用户的历史行为和忠诚度，提供不同层次的优惠，优待忠实用户

奖池（优惠券数量）限制上限

**技术风控**

限流、自动扩容伸缩

黑名单（客服标记、系统监测）；布隆过滤器

大数据用户画像

#### 分布式集群架构下怎么保证并发安全

![image-20250713100556197](F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250713100556197.png)

#### 让你设计一个扫描登录怎么实现？

**登录过程**

<img src="F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250713101030210.png" alt="image-20250713101030210" style="zoom:50%;" />

**生成二维码**

生成二维码ID和状态到redis

根据二维码ID生成图片

<img src="F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250713101110241.png" alt="image-20250713101110241" style="zoom:50%;" />

**扫码**

![image-20250713102217967](F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250713102217967.png)

<img src="F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250713102548288.png" alt="image-20250713102548288" style="zoom:50%;" />

**确认登录**

![image-20250713102706601](F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250713102706601.png)

#### 如何设计分布式日志存储架构

**单体项目**

1.部署简单

2.成本低、易维护

3.性能高、稳定

<img src="F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250713102926734.png" alt="image-20250713102926734" style="zoom:33%;" />

**分布式(文件)**

日志文件，不便于排查

<img src="F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250713103105110.png" alt="image-20250713103105110" style="zoom:33%;" />

抽取出日志管理系统

<img src="F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250713103225261.png" alt="image-20250713103225261" style="zoom:33%;" />

日志系统—MongoDB存储

日志数据量大，灵活 数据格式，支持复杂的查询

<img src="F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250713103409023.png" alt="image-20250713103409023" style="zoom:33%;" />

日志系统—ELK存储(主流)

LogStash重量级，功能多，可用FileBeat轻量级代替，在客户端完成日志的收集

<img src="F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250713103635442.png" alt="image-20250713103635442" style="zoom:33%;" />

日志系统—Loki

属于Grafana的一个插件，对应Elasticsearch

<img src="F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250713104001496.png" alt="image-20250713104001496" style="zoom:33%;" />

#### 使用redis出现缓存击穿雪崩穿透怎么解决

**缓存击穿**

解决方案：

永不过期

加锁排队

<img src="F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250713104633376.png" alt="image-20250713104633376" style="zoom:50%;" />

**缓存雪崩**

解决方案：

加锁排队

随机失效时间 

redis高可用

<img src="F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250713105736156.png" alt="image-20250713105736156" style="zoom:50%;" />

**缓存穿透**

解决方案：

参数校验

缓存空对象

布隆过滤器

<img src="F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250713110024909.png" alt="image-20250713110024909" style="zoom:50%;" />

#### 如何使用redis记录上亿用户连续登录天数

**Bitmap说明**

String类型=512M

1byte=8个bit位=8个状态

512M=1024byte * 1024 * 512 * 8 = 4294967296个状态

#### 给你一个亿Redis keys统计双方的共同好友

**Redis ：**

​	SINTERSTORE功能

<img src="F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250716220744176.png" alt="image-20250716220744176" style="zoom:50%;" />

#### redis如何实现上亿用户实时积分排行榜

**ZSet**

<img src="F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250716221158980.png" alt="image-20250716221158980" style="zoom:33%;" />

**分桶：**

<img src="F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250716221329756.png" alt="image-20250716221329756" style="zoom:33%;" />

#### 内存200M读取1G文件并统计重复内容

**分块读取**

<img src="F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250716221602828.png" alt="image-20250716221602828" style="zoom:33%;" />

**文件分片** (内容不重复)

<img src="F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250716221749489.png" alt="image-20250716221749489" style="zoom:33%;" />

**逐个统计 **

<img src="F:\LearnDoc\1-架构师-20250406\Java八股文\场景解决.assets\image-20250716221926421.png" alt="image-20250716221926421" style="zoom:33%;" />

**查询200条数据耗时200ms怎么在500ms内查询1000条数据**

多线程，Feature

考虑返回结果线程安全